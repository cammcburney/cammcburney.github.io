---
layout: post
author: Cameron McBurney
tags: [tirnanog]
---

# Tir Na nOg // Copyright Hawthorn House Games LTD
## 3D Adventure / Puzzle Game
### C++ / Unreal Engine

*Tir Na nOg is a narrative driven adventure and puzzle game developed by Hawthorn House Games LTD*

***Designing An Engaging & Scalable Puzzle System***

After being onboarded as a puzzle designer and programmer for Tir Na nOg, my first challenge was pivotal to how the gameplay would evolve and engage players and make development manageable and scalable within our small team.

The requirements were that the puzzles would need to be managed across multiple levels and would need to be able to be dynamically activated and their states stored between gameplay sessions and level transitions.
After much deliberating, a game instance subsystem, instantiated each time the game was loaded, seemed ideal in communicating the current state of each puzzle and any future changes they would require.
The system would be driven by gameplay tags unique to each puzzle and it's state recorded dynamically at runtime.

This brought about the first challenge, how would the system know which puzzles to load and where they belonged?

The solution? A data table containing the unique PuzzleID and a reference to FName of the Level it was stored in.

When the subsystem loaded it would grab a reference to the table from the game instance.

.h
```
UPROPERTY()
TObjectPtr<UGameInstance> GameInstance;
```

.cpp
```
GameInstance = GetGameInstance();
if (GameInstance)
{
    DataTable = GameInstance->GetPuzzleTable();
}
```

As the system was initialised, the data was read and converted into a map to be referenced when loading or updating puzzle states.

```
UPROPERTY()
TMap<FName, FGameplayTagContainer> PuzzleLevelMap;
```

A further requirement was that many puzzles would have prerequisites for them to be activated, such as opening a lock with a key. These needed to be tracked and communicated to the puzzles on demand.

Preventing directly coupling functions between each distinct puzzle class and the management system was essential in keeping the code clean and maintainable and delegates offered the perfect solution.

.h
```
DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FCompletePrerequisite, FGameplayTag, GameplayTag);

UPROPERTY(BlueprintAssignable)
FCompletePrerequisite OnCompletePrerequisite;
```

Abstract classes named 'AKey' and 'ALock' were the solution, the key and the lock would share the puzzle id (or ids) that they would link to. On activating the 'lock' whether through the key or other means a message was sent to the subsystem containing the unique Puzzle ID. If the id was valid and the puzzle was in the level the delegate would broadcast.

.cpp
```
void UTnoPuzzleMgmtSubsystem::PrereqCompleted(const FGameplayTag& PuzzleID)
{
    if (PuzzleID.IsValid())
    {
        if (IsPuzzleInLevel(PuzzleID))
        {
            OnCompletePrerequisite.Broadcast(PuzzleID);
        }
        else
        {
            RecordPuzzleState(PuzzleID);
        }
    }
}
```

This was bound inside the Puzzle Base class to its own function managing it's internal prerequisite count.

.cpp
```
PuzzleMgmtSubsystem->OnCompletePrerequisite.AddDynamic(this, &ATnoPuzzleBase::CompletePrerequisite);
```

Any listening puzzles would then check if the Puzzle ID matched their own and would accordingly add a completed requirement to their total and check if they were ready to be activated or required further prerequisites.

If the puzzle was not in the level, the total count would increase and be recorded to the save file using structs filled by the Puzzle's own member variables.

PuzzleStructs.h
```
USTRUCT(BlueprintType)
struct FPuzzleState
{
	GENERATED_BODY()

	FGameplayTag PuzzleID;
	FString LevelName;
	bool IsActive;
	bool IsCompleted;
	int8 PrerequisitesCompleted;
};
```

***Results and Scalability***

This architecture has proved highly effective throughout development. Using a mediator pattern helped reduce dependencies between objects and gave them a central source of communication and truth. This has greatly benefitted development speed through the following:

- **Decoupled Design**: Puzzles remain independent of each other and can communicate via the mediator.
- **Quick Iteration**: New puzzles could be created by inheriting from the base class without modifying core systems.
- **Reliable State Management**: Puzzle progress is persistent between saving, loading and level transitions
- **Performance**: The map and tag based lookup system provided efficient runtime queries and ease of puzzle state management.

From the initial prototype puzzles and looking ahead to the future, the scaling of systems and intercommunication between levels will now be a much easier task and will allow me and the other developer focus on what's most important to the players, having tons of fun, high-quality puzzles!